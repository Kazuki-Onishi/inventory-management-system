































import React, { createContext, useState, useEffect, ReactNode } from 'react';































import { Store, Item, CatalogItem, Location, Stocktake, NewStore, NewItem, NewCatalogItem, NewLocation, NewSubLocation, SubLocation, Category, NewCategory, Vendor, NewVendor } from '../types';
import { ensureLocationHumanId, generateNextLocationHumanId, generateNextSubLocationHumanId } from '../lib/locations';































































interface ToastState {































  message: string;































  type: 'success' | 'error';































}































































interface AppContextType {































  language: 'en' | 'ja';































  setLanguage: (lang: 'en' | 'ja') => void;































  currentStore: Store | null;































  setCurrentStore: (store: Store | null) => void;































  accessibleStores: Store[];































  // FIX: Update type to allow functional updates like set(prev => ...).































  setAccessibleStores: React.Dispatch<React.SetStateAction<Store[]>>;































  isSidebarOpen: boolean;































  toggleSidebar: () => void;































  items: Item[];
  catalogItems: CatalogItem[];
  setCatalogItems: React.Dispatch<React.SetStateAction<CatalogItem[]>>;
  vendors: Vendor[];
  setVendors: React.Dispatch<React.SetStateAction<Vendor[]>>;































  locations: Location[];































  stocktakes: Stocktake[];































  categories: Category[];































  loadOfflineData: (data: { items: Item[], catalogItems: CatalogItem[], vendors: Vendor[], locations: Location[], stocktakes: Stocktake[], categories: Category[] }) => void;































  saveStocktakes: (updatedStocktakes: Stocktake[]) => void;
  removeStocktakes: (stocktakeIds: string[]) => void;































  addStore: (newStore: NewStore) => Promise<Store>;































  addItem: (newItem: NewItem) => Promise<Item>;
  addCatalogItem: (item: NewCatalogItem) => Promise<CatalogItem>;
  updateCatalogItem: (item: CatalogItem) => Promise<void>;
  deleteCatalogItem: (id: string) => Promise<void>;































  updateItem: (item: Item) => Promise<void>;































  deleteItem: (itemId: string) => Promise<void>;































  addLocation: (newLocation: NewLocation) => Promise<Location>;































  addSubLocation: (locationId: string, newSubLocation: NewSubLocation) => Promise<Location>;































  updateLocation: (locationId: string, data: Partial<NewLocation>) => Promise<void>;































  updateSubLocation: (parentId: string, subLocation: SubLocation) => Promise<Location>;































  deleteLocation: (locationId: string) => Promise<void>;































  deleteSubLocation: (parentId: string, subLocationId: string) => Promise<void>;































  addCategory: (newCategory: NewCategory) => Promise<Category>;































  updateCategory: (category: Category) => Promise<void>;































  deleteCategory: (categoryId: string) => Promise<void>;































  addVendor: (newVendor: NewVendor) => Promise<Vendor>;
  updateVendor: (vendor: Vendor) => Promise<void>;
  deleteVendor: (vendorId: string) => Promise<void>;
  clearData: () => void;































  toast: ToastState | null;































  showToast: (message: string, type?: 'success' | 'error') => void;































  hideToast: () => void;































}































































export const AppContext = createContext<AppContextType>({































  language: 'ja',































  setLanguage: () => {},































  currentStore: null,































  setCurrentStore: () => {},































  accessibleStores: [],































  setAccessibleStores: () => {},































  isSidebarOpen: true,































  toggleSidebar: () => {},































  items: [],
  catalogItems: [],
  setCatalogItems: () => {},
  vendors: [],
  setVendors: () => {},































  locations: [],































  stocktakes: [],































  categories: [],































  loadOfflineData: () => {},































  saveStocktakes: () => {},
  removeStocktakes: () => {},































  addStore: async () => ({} as Store),































  addItem: async () => ({} as Item),
  addCatalogItem: async () => ({} as CatalogItem),
  updateCatalogItem: async () => {},
  deleteCatalogItem: async () => {},































  updateItem: async () => {},































  deleteItem: async () => {},































  addLocation: async () => ({} as Location),































  addSubLocation: async () => ({} as Location),































  updateLocation: async () => {},































  updateSubLocation: async () => ({} as Location),































  deleteLocation: async () => {},































  deleteSubLocation: async () => {},































  addCategory: async () => ({} as Category),































  updateCategory: async () => {},































  deleteCategory: async () => {},































  addVendor: async () => ({} as Vendor),
  updateVendor: async () => {},
  deleteVendor: async () => {},
  clearData: () => {},































  toast: null,































  showToast: () => {},































  hideToast: () => {},































});































































export const AppProvider: React.FC<{ children: ReactNode }> = ({ children }) => {































  const [language, setLanguageState] = useState<'en' | 'ja'>('ja');































  const [currentStore, setCurrentStoreState] = useState<Store | null>(null);































  const [accessibleStores, setAccessibleStores] = useState<Store[]>([]);































  const [isSidebarOpen, setSidebarOpen] = useState(true);































  































  // State for offline data































  const [items, setItems] = useState<Item[]>([]);
  const [catalogItems, setCatalogItems] = useState<CatalogItem[]>([]);
  const [vendors, setVendors] = useState<Vendor[]>([]);































  const [locations, setLocations] = useState<Location[]>([]);































  const [stocktakes, setStocktakes] = useState<Stocktake[]>([]);































  const [categories, setCategories] = useState<Category[]>([]);































  const [toast, setToast] = useState<ToastState | null>(null);































































































  useEffect(() => {































    const savedLang = localStorage.getItem('ims-lang') as 'en' | 'ja';































    if (savedLang) {































      setLanguageState(savedLang);































    }































    const savedStore = localStorage.getItem('ims-store');































    if (savedStore) {































      setCurrentStoreState(JSON.parse(savedStore));































    }































  }, []);































































  const setLanguage = (lang: 'en' | 'ja') => {































    localStorage.setItem('ims-lang', lang);































    setLanguageState(lang);































  };































  































  const setCurrentStore = (store: Store | null) => {































    if (store) {































        localStorage.setItem('ims-store', JSON.stringify(store));































    } else {































        localStorage.removeItem('ims-store');































    }































    setCurrentStoreState(store);































  };































  































  const toggleSidebar = () => setSidebarOpen(!isSidebarOpen);































































  const loadOfflineData = (data: { items: Item[], catalogItems: CatalogItem[], vendors: Vendor[], locations: Location[], stocktakes: Stocktake[], categories: Category[] }) => {

    const normalizedItems = data.items.map(item => ({
      ...item,
      categoryId: item.categoryId ?? null,
      vendorId: item.vendorId ?? null,
    }));

    setItems(normalizedItems);
    setCatalogItems(data.catalogItems);
    setVendors(data.vendors);

    setLocations(data.locations.map(ensureLocationHumanId));

    setStocktakes(data.stocktakes);

    setCategories(data.categories);

  };































  































  const saveStocktakes = (updatedStocktakes: Stocktake[]) => {































    setStocktakes(prevStocktakes => {































      const stocktakeMap = new Map(prevStocktakes.map(st => [st.id, st]));































      updatedStocktakes.forEach(updated => {































        const existing = prevStocktakes.find(p => p.itemId === updated.itemId && p.locationId === updated.locationId && p.subLocationId === updated.subLocationId);































        const idToUpdate = updated.id.startsWith('new-') ? existing?.id || updated.id : updated.id;































  































        if (idToUpdate) {































            stocktakeMap.set(idToUpdate, { ...stocktakeMap.get(idToUpdate), ...updated, id: idToUpdate });































        } else {































            stocktakeMap.set(`new-${Date.now()}-${Math.random()}`, updated);































        }































      });































      return Array.from(stocktakeMap.values());































    });































  };

  const removeStocktakes = (stocktakeIds: string[]) => {
    if (stocktakeIds.length === 0) {
      return;
    }

    const removalSet = new Set(stocktakeIds);
    setStocktakes(prev => prev.filter(stocktake => !removalSet.has(stocktake.id)));
  };































































  const addStore = async (newStore: NewStore): Promise<Store> => {































      const storeWithId: Store = { ...newStore, id: `offline-store-${Date.now()}` };































      setAccessibleStores(prev => [...prev, storeWithId]);































      return storeWithId;































  };































































  const addItem = async (newItem: NewItem): Promise<Item> => {































      const itemWithId: Item = { 































          ...newItem, 































          id: `offline-item-${Date.now()}`,































          normalizedName: newItem.name.toLowerCase().replace(/\s+/g, '_'),































          categoryId: newItem.categoryId ?? null,
          vendorId: newItem.vendorId ?? null,































      };































      setItems(prev => [...prev, itemWithId]);































      return itemWithId;































  };































  































  const addCatalogItem = async (newCatalogItem: NewCatalogItem): Promise<CatalogItem> => {
    const now = new Date().toISOString();
    const normalizedName = (newCatalogItem.nameJa || '')
      .normalize('NFKC')
      .toLowerCase()
      .replace(/\s+/g, ' ')
      .trim();

    const catalogItemWithId: CatalogItem = {
      ...newCatalogItem,
      id: `offline-catalog-${Date.now()}`,
      normalizedName,
      createdAt: now,
      updatedAt: now,
      thumbnailUrl: newCatalogItem.thumbnailUrl ?? newCatalogItem.mainImageUrl,
    };

    setCatalogItems(prev => [...prev, catalogItemWithId]);
    return catalogItemWithId;
  };

  const updateCatalogItem = async (catalogItem: CatalogItem): Promise<void> => {
    setCatalogItems(prev => prev.map(item => (item.id === catalogItem.id ? { ...catalogItem } : item)));
  };

  const deleteCatalogItem = async (catalogItemId: string): Promise<void> => {
    setCatalogItems(prev => prev.filter(item => item.id !== catalogItemId));
  };

  const updateItem = async (item: Item): Promise<void> => {































    setItems(prev => prev.map(i => i.id === item.id ? item : i));































  };































































  const deleteItem = async (itemId: string): Promise<void> => {































    setItems(prev => prev.filter(i => i.id !== itemId));































    setStocktakes(prev => prev.filter(st => st.itemId !== itemId));































  };































































































  const addLocation = async (newLocation: NewLocation): Promise<Location> => {
    const providedHumanId = newLocation.humanId?.trim().toUpperCase();
    const existingForStore = locations
      .filter(location => location.storeId === newLocation.storeId)
      .map(ensureLocationHumanId);

    let humanId = providedHumanId;
    if (humanId) {
      const duplicate = existingForStore.some(location => location.humanId === humanId);
      if (duplicate) {
        throw new Error('LOCATION_HUMAN_ID_ALREADY_EXISTS');
      }
    } else {
      humanId = generateNextLocationHumanId(existingForStore);
    }

    const locationWithId: Location = ensureLocationHumanId({
      id: `offline-loc-${Date.now()}`,
      name: newLocation.name.trim(),
      description: newLocation.description || '',
      storeId: newLocation.storeId,
      humanId,
      imageUrl: newLocation.imageUrl ?? null,
      sublocations: [],
    });

    setLocations(prev => [...prev, locationWithId]);
    return locationWithId;
  };

const addSubLocation = async (locationId: string, newSubLocation: NewSubLocation): Promise<Location> => {
    let updatedParentLocation: Location | undefined;
    setLocations(prev => prev.map(loc => {
        if (loc.id === locationId) {
            const ensuredParent = ensureLocationHumanId(loc);
            const subHumanId = generateNextSubLocationHumanId(ensuredParent);
            const subLocationWithIds: SubLocation = {
                id: `offline-subloc-${Date.now()}`,
                humanId: subHumanId,
                name: newSubLocation.name?.trim() || '',
                description: newSubLocation.description || '',
                imageUrl: newSubLocation.imageUrl ?? null,
            };
            updatedParentLocation = {
                ...ensuredParent,
                sublocations: [...(ensuredParent.sublocations || []), subLocationWithIds],
            };
            return updatedParentLocation;
        }
        return ensureLocationHumanId(loc);
    }));
    if (!updatedParentLocation) throw new Error('Parent location not found');
    return updatedParentLocation;
  };

const updateLocation = async (locationId: string, data: Partial<NewLocation>): Promise<void> => {































    setLocations(prev => prev.map(loc => 































        loc.id === locationId ? { ...loc, ...data, id: loc.id, storeId: loc.storeId } : loc































    ));































  };































































  const updateSubLocation = async (parentId: string, subLocation: SubLocation): Promise<Location> => {































      let updatedParentLocation: Location | undefined;































      setLocations(prev => prev.map(loc => {































          if (loc.id === parentId) {































              const updatedSublocations = loc.sublocations?.map(sub => 































                  sub.id === subLocation.id ? { ...sub, ...subLocation, imageUrl: subLocation.imageUrl ?? null } : sub































              ) || [];































              updatedParentLocation = { ...loc, sublocations: updatedSublocations };































              return updatedParentLocation;































          }































          return loc;































      }));































      if (!updatedParentLocation) throw new Error("Parent location not found");































      return updatedParentLocation;































  };































































  const deleteLocation = async (locationId: string): Promise<void> => {































      setLocations(prev => prev.filter(loc => loc.id !== locationId));































      // Also remove stocktakes in that location































      setStocktakes(prev => prev.filter(st => st.locationId !== locationId));































  };































































  const deleteSubLocation = async (parentId: string, subLocationId: string): Promise<void> => {































      setLocations(prev => prev.map(loc => {































          if (loc.id === parentId) {































              const updatedSublocations = loc.sublocations?.filter(sub => sub.id !== subLocationId) || [];































              return { ...loc, sublocations: updatedSublocations };































          }































          return loc;































      }));































      // Also remove stocktakes in that sublocation































      setStocktakes(prev => prev.filter(st => st.subLocationId !== subLocationId));































  };































  































  const addCategory = async (newCategory: NewCategory): Promise<Category> => {































    const categoryWithId: Category = { ...newCategory, id: `offline-cat-${Date.now()}` };































    setCategories(prev => [...prev, categoryWithId]);































    return categoryWithId;































  };































































  const updateCategory = async (category: Category): Promise<void> => {































    setCategories(prev => prev.map(c => c.id === category.id ? category : c));































  };































































  const deleteCategory = async (categoryId: string): Promise<void> => {































    setCategories(prev => prev.filter(c => c.id !== categoryId));































    // Un-categorize items that belonged to the deleted category































    setItems(prev => prev.map(item => item.categoryId === categoryId ? { ...item, categoryId: null } : item));































  };































































  const addVendor = async (newVendor: NewVendor): Promise<Vendor> => {
    const vendorWithId: Vendor = { ...newVendor, id: `offline-vendor-${Date.now()}` };
    setVendors(prev => [...prev, vendorWithId]);
    return vendorWithId;
  };
  const updateVendor = async (vendor: Vendor): Promise<void> => {
    setVendors(prev => prev.map(existing => existing.id === vendor.id ? vendor : existing));
  };
  const deleteVendor = async (vendorId: string): Promise<void> => {
    setVendors(prev => prev.filter(vendor => vendor.id !== vendorId));
    setItems(prev => prev.map(item => item.vendorId === vendorId ? { ...item, vendorId: null } : item));
  };
  const clearData = () => {































    setItems([]);
    setCatalogItems([]);
    setVendors([]);































    setLocations([]);































    setStocktakes([]);































    setCategories([]);































    setCurrentStore(null);































    setAccessibleStores([]);































    localStorage.removeItem('ims-store');































  }































































  const showToast = (message: string, type: 'success' | 'error' = 'success') => {































    setToast({ message, type });































  };































  































  const hideToast = () => {































    setToast(null);































  };































































  return (































    <AppContext.Provider value={{ 































        language, setLanguage, 































        currentStore, setCurrentStore, 































        accessibleStores, setAccessibleStores, 































        isSidebarOpen, toggleSidebar,































        items, catalogItems, setCatalogItems, vendors, setVendors, locations, stocktakes, categories,































        loadOfflineData,































        saveStocktakes,
        removeStocktakes,































        addStore,































        addItem,
        addCatalogItem,
        updateCatalogItem,
        deleteCatalogItem,































        updateItem,































        deleteItem,































        addLocation,































        addSubLocation,































        updateLocation,































        updateSubLocation,































        deleteLocation,































        deleteSubLocation,































        addCategory,































        updateCategory,































        deleteCategory,































        addVendor,
        updateVendor,
        deleteVendor,
        clearData,































        toast, showToast, hideToast































    }}>































      {children}































    </AppContext.Provider>































  );































};
































